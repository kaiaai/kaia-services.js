define(["exports"],function(e){"use strict";class t{constructor(){if(this._resolveFunc=null,this._rejectFunc=null,this._initialized=!1,this._closed=!1,this._listener=null,this._messageId=0,this._id="",t._created)throw"Only one instance allowed";t._created=!0}postEvent(e){"init"===e.event&&(e.err&&null!=this._rejectFunc?this._rejectFunc(e.err):e.err||null==this._resolveFunc||this._resolveFunc(e.event)),null!=this._listener&&this._listener(e.err,e)}parseQuery(e){const t={},s=("?"===e[0]?e.substr(1):e).split("&");for(var n=0;n<s.length;n++){let e=s[n].split("=");t[decodeURIComponent(e[0])]=decodeURIComponent(e[1]||"")}return t}init(e){if(this._initialized)throw"Already initialized";if(this._initialized=!0,void 0===e)throw"io() required";let t;if(e.io?this._socket=e.socket:this._socket=e,e.eventListener&&(this._listener=e.eventListener),e.token)t=e.token;else{const e=window.location.search.substring(1);t=this.parseQuery(e).token}if(!t)throw"Missing token";if(!this._socket)throw"Missing io()";this._socket.on("connect",()=>this._onConnect()),this._socket.on("reconnect",e=>this._onReconnect(e)),this._socket.on("disconnect",e=>this._onDisconnect(e)),this._socket.on("connect_timeout",e=>this._onConnectTimeout(e)),this._socket.on("connect_error",e=>this._onConnectError(e)),this._socket.on("participants",e=>this._onParticipants(e)),this._socket.on("join",e=>this._onJoin(e)),this._socket.on("leave",e=>this._onLeave(e)),this._socket.on("message",e=>this._onMessage(e)),this._socket.on("authResult",e=>this._onAuthResult(e)),this._socket.on("reconnecting",e=>this._onReconnecting(e)),this._socket.on("reconnect_error",e=>this._onReconnectError(e)),this._socket.on("reconnect_failed",e=>this._onReconnectFailed(e)),this._socket.on("ping",()=>this._onPing()),this._socket.on("pong",e=>this._onPong(e)),this._socket.connect("/");return this._makePromise({})}_onConnect(){console.log("_onConnect()")}_onReconnect(e){this._listener&&this._listener(!1,{event:"reconnect",attemptNumber:e,err:!1})}_onDisconnect(e){this._listener&&this._listener(!1,{event:"disconnect",reason:e,err:!1})}_onConnectTimeout(e){this._listener&&this._listener(!1,{event:"connectTimeout",timeout:e,err:!1})}_onConnectError(e){this._listener&&this._listener(!0,{event:"connectError",error:e,err:!0})}_onParticipants(e){console.log("_onParticipants()"),console.log(e)}_onJoin(e){console.log("_onJoin()"),console.log(e)}_onLeave(e){console.log("_onLeave()"),console.log(e)}_onMessage(e){this._listener&&this._listener(!1,{event:"message",message:e.payload,err:!1}),console.log("_onMessage()"),console.log(e)}_onAuthResult(e){console.log("_onAuthResult()"),console.log(e)}_onReconnecting(e){this._listener&&this._listener(!1,{event:"reconnecting",attemptNumber:e,err:!1})}_onReconnectError(e){this._listener&&this._listener(!0,{event:"reconnectErro",err:e})}_onReconnectFailed(e){this._listener&&this._listener(!1,{event:"reconenctFailed",err:e})}_onPing(){}_onPong(e){this._latency=e}_clearCallback(){this._resolveFunc=null,this._rejectFunc=null}_resolve(e){let t=this._resolveFunc;this._clearCallback(),null!==t&&t(e)}_reject(e){let t=this._rejectFunc;this._clearCallback(),null!==t&&t(e)}join(e){if(this.isClosed())throw"Messaging instance has been closed";if(!e)throw"Room name or array of room names required";"string"==typeof e&&(e=[e]),this._rooms=e;return this._makePromise({})}leave(e){if(this.isClosed())throw"Messaging instance has been closed";if(!e)throw"Room ID or array of room IDs required";"string"==typeof e&&(e=[e]);return this._makePromise({})}participants(e){if(this.isClosed())throw"Messaging instance has been closed";return this._makePromise({})}rooms(e){if(this.isClosed())throw"Messaging instance has been closed";return this._makePromise({})}_send(e,t){this._messageId=this._messageId+1,t.id=this._messageId,this._socket.emit(e,t)}send(e,t){if(this.isClosed())throw"Messaging instance has been closed";if(void 0===e)throw"Message required";if(void 0===t&&(t=this._rooms),"string"==typeof t&&(t=[t]),!Array.isArray(t))throw"Rooms array required";this._send(e,t)}id(){if(this.isClosed())throw"Messaging instance has been closed";return this._id}latency(){if(this.isClosed())throw"Messaging instance has been closed";return this._latency}_makePromise(e){if(e.err)throw e.err;return new Promise((e,t)=>{this._resolveFunc=e,this._rejectFunc=t})}isClosed(){return this._closed}close(){this._closed=!0;const e=!1;if(e)throw e;this._clearCallback(),this._listener=null}setEventListener(e){this._listener=e}}t._created=!1,e.Messaging=t,e.createMessaging=async function(e){if("object"!=typeof e)throw"io() required";e.io||(e={io:e});const s=new t,n=await s.init(e);if("string"==typeof n)throw n;return s},Object.defineProperty(e,"__esModule",{value:!0})});